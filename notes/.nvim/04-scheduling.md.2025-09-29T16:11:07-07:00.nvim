# Scheduling

- Even though CPUs today have many cores, there are still many more processes than cores
    - How do we get these jobs to run in parallel
        - Job: a process, task, thread, etc.

## CPU Scheduling
- **CPU Scheduling** is sharing a core by multiple processes
- A **Context Switch** is when we stop running one process and start running another
    - Doesn't end the process, more of a pause. Can be resumed exactly where it left off
- The **Ready Queue** is a queue of processes that are waiting for some CPU time
    - Linked list in memory
- **Scheduling** is picking one process to run next from the ready queue(s)
- **Non-preemptive Scheduling**: a process gives up the core when it terminates or 'waits' for an
  operation that takes a long time (e.g. sleep, wait)
- **Scheduling Criteria**: we want to maximize **CPU utilization**, keeping the CPU as busy as
  possible
    - We also want to maximize **throughput**, the number of processes that complete their execution
      per time unit
    - We want to minimize **turnaround time**, the time to execute a process, submission to
      termination
      queue
    - We want to minimize **waiting time**, the amount of time a process has been waiting in queue
    - We want to minimize **response time**, the amount of time it takes from when a request is
      submitted until the first response

## Scheduling Algorithms
- The simplest algorithm is **First Come First Served (FCFS)**
    - Run in the order of arrival, non-preemptive
    - The issue with this algorithm is that a long process can sabotage all other processes
- **Waiting Time** is the sum of how long each process needs to wait upon arrival
    - This is how we assess how good an algorithm is
- **Shortest Job First (SJF)**: among the remaining processes, pick the process with the shortest
  execution time
    - Non-preemptive algorithm, once running, a job runs to completion
- **Shortest Remaining Time First (SRTF)**: schedule a process with the shortest remaining execution time
    - This is a preemptive algorithm, meaning when a new job arrives, it can interrupt the currently
      executing job
- **Round Robin (RR)**: Forget about how long each process needs, just give everyone equal length
  turns
    - A **quantum** is how long a turn each process gets on the CPU
- **Priority Scheduling**: run the process in ready queue with the highest priority
    - Can be either preemptive or non-preemptive
- A **hard real-time system** has strict deadlines that must not be missed
    - Consequences for missing the deadline are catastrophic
- **Soft real time systems** have approximate deadlines that shouldn't be missed by much
    - Real time tasks have higher priority
- **Starvation** is when a lower priority process may never run
    - Constantly interrupted by higher priority tasks, or may never even get to start
- In **Multilevel Queue Scheduling**, we group processes based on categories
    - Each category is given its own ready queue and priority value
    - Round robin, but give more turns to higher priority queues
    - During each queues turn, it uses some scheduling algorithm from above to pick what process in
      that queue is scheduled
    - Move a process to a lower priority if it takes too much CPU time
- In Linux, the 'nicest' processes are the ones that most often give up their spot to other
  processes
    - Niceness ranges from -20 to +19
    - Real-time processes have higher priority than any 'nice/not nice' priorities
- **Linux Completely Fair Scheduler** makes it so that the longer a process runs, the less chance it
  gets to run
    - Tries to make sure that each process uses a similar amount of CPU time
