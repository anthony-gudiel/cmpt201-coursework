# Processes

- **Program**: compiled executable file
- **Process**: a running program
- The CPU can execute instructions from memory
    - Therefore a program must be in memory to run
- To begin executing a program, the OS will allocate space in memory for the program to run
    - OS neatly organizes everything before executing the program and starting the process
- ***syscalls*** can be used to control processes
    - Core syscalls include: **fork()**, **exec()**, **wait()**
- ***man*** page section numbers: used when we need to pick between two things of the same name
    - man 3 <name> will bring you to the c standard library


## Making a New Process
- Changing a variable's value in one process does not affect any variables in other processes
    - Isolated memory spaces
    - Pointers in one process cannot access the memory of the other
    - Even if the same address is referenced
    - Unless OS explicitly gives permission to share addresses
- The initial process is called the parent process
- The parent wants to make a child process
    - The parent will call ***fork()*** to have the OS start a new process
    - fork() is a syscall
- fork() creates a child process that is an identical copy of the calling process
    - It is called once, but it returns twice, the new process being the child
- For the parent, fork() returns the process ID of the child (knows the child)
- For the child, fork() returns 0
    - However, children can call ***ppid()*** to find their parent
- The parent and the child are the same program


## Replacing a Current Program in Process
- When called, **`exec()`** will:
    - Remove the currently running program from this process's memory
    - Load a new program into memory
    - Start executing the new program
    - Everything from the previous program is gone (e.g. allocated memory, stack, heap)
- Each call of `exec()` must end with a `NULL` pointer
    - Both `execv()` and `execl()`
- When a program is executed, the OS hands it some command-line arguments
    - `args[0]` is always the program's name on disk
    - `args[1]` and beyond are the other arguments
- `exec()` takes what program to execute, and what arguments to pass the new process
- See code example in 'forkexec.c'

## Waiting for a Child
- **`wait()`** waits on a child process's termination and obtains its status
    - Family of processes, we typically use `waitpid()`
- The first argument for `waitpid()` is the PID that we want to wait on
    - Alternatively, we can use -1 to wait for any child (first child that finishes)
- The second argument for `waitpid()` is a pointer to an int to store the exit status of the process
    - We can pass `NULL` to this argument if we don't care about the exit status
    - We typically declare an int local variable to allocate space for wstatus, which is our output
      parameter
- The third argument for `waitpid()` is options, where we can specify non-blocking (don't wait)

## Zombies and Orphans
- A **zombie** is a process where the child process terminates, but the parent hasn't called
  `wait()` yet
    - `wait()` frees the target terminated process from memory
    - Therefore we should always call wait on a child process, even if we don't really care about it
- An **orphan** process is one where the child is running, but the parent is terminated
    - No longer has a parent
- The OS will re-pair orphans to init, where `wait()` will be called on them, terminating the
  orphan (?)

## What Went Wrong: errno
- `errno()` adds more information about what went wrong
    - It's an integer value that is set by system calls and library functions when there's an error
    - Status code set by a system call if there's an error
