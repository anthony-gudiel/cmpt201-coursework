# Networking

## Networking Stack Basics
- Software uses a **network stack** to organize responsibilities into layers
- The **physical layer** does the hardware control
    - In charge of physically sending and receiving data
    - Analogy: package delivery needs a car and a driver
- The **link/MAC layer** does local network addressing and routing
    - e.g. wired or wireless local network
    - MAC addresses for devices = Medium Address Control
- The **IP/network layer** does inter-network addressing and routing
    - IP = Internet Protocol
    - Uses IP address for addressing
- The **transport layer** can do packet tracking and retransmission
    - Takes care of issues like: lost packets, out of order packets, duplicate packets
    - TCP: Transmission Control Protocol - provides protection against these issues
    - UDP : User Datagram Protocol - does not provide any protection, raw datagrams/packets
    - TCP builds upon a UDP packet
    - Port numbers are used to identify where on a computer the packet should be sent to
        - Which application
- The **application layer** is what the application is doing

## Socket Interface
- `socket()` creates a socket and returns a file descriptor
    - The argument `int domain` specifies what protocol to use
        - Defines a set of rules that an entity needs to follow to communicate with another entity
          using the same rules
        - Examples of domains are AF_UNIX, AF_INET, AF_INET6
    - The argument `int type` specifies either TCP or UDP
        - TCP = SOCK_STREAM. Sequenced, reliable, two-way, connection based byte stream
        - UDP = SOCK_DGRAM. Datagrams, meaning connectionless, unreliable, packet size is limited
    - The argument `int protocol` will always be 0 in our case
- TCP socket sequence:
    - `bind()` binds the socket to an address using an address struct
        - `struct sockaddr`
    - `listen()` marks the socket as passive
        - By default, a socket is active, so we must change that if we want to wait on a connection
    - `accept()` will accept a new connection, and returns a new socket to use for the new connection
        - Blocking call
    - `connect()` is how the client connects to a passive socket
- Connectionless means that we don't establish the connection first
    - No active ongoing connection
- UDP socket sequence:
    - There are no passive or active sockets
    - `recvfrom()`
    - `sendto()`
- Client does not need to use `bind()` in UDP

## AF_INET Data Structure
- Uses `struct sockaddr_in`
    - "in" for internet
    - Contains family, port number, internet address, and some padding
- Computers represent IP addresses as 4 byte values
    - `inet_pton()` converts the presentation representation (human) to the network representation
      (computer)
    - `inet_ntop()` does the opposite
- 127.0.0.1 is the loopback address
    - `INADDR_LOOPBACK`
    - Data sent and received locally, nothing onto the network
- Wildcard address: `INADDR_ANY`
    - `bind()` to socket with wildcard address listens to any address
- `bind()` needs a port number that identifies a specific socket on the machine
    - As well as an IP
    - SSH = port 22
    - HTTP = port 80
- An ephemeral port is when we don't bind to a specific port, so an unused random port is picked for
  us

## Byte Order & Hosts
- **Little Endian**: store the little part (least significant byte) first (at a lower address)
    - **Big Endian**: store the big part first
- Network byte order is big endian
- `uint32_t htonl(uint32_t hostlong)` -> host to network long
    - Only needed for multi-byte values

## Handling Multi Client Connection
- Recall that `accept()` returns a new socket file descriptor for the new client connection
- How to handle multiple connections?
    - **1**: The server can create new threads for each accepted connection
        - However this leads to higher overhead of creating new processes/threads
    - **2**: Create an array of open sockets and poll with non-blocking calls
    - Non-blocking `accept()`, `read()`, and `write()`
        - However we can't be certain of our array size
        - Continuously polling will maximize CPU usage
    - **3**: Kernel notifies the program when a socket event happens
        - **I/O multiplexing**: Use syscalls to monitor multiple file descriptors
            - A program is notified when a monitored fd is ready to read or write
            - Use `select()`, `poll()`, `epoll()` to check when file descriptors can perform I/O
            - However, it's more complex to maintain a list of fds to monitor
        - `epoll_create()` creates a monitor object that maintains the monitoring list
        - `epoll_ctl()` allows us to add, remove, or modify a fd to the epoll
            - Start by monitoring for `accept()`
        - `epoll_wait()` waits for the fd to be available for I/O

