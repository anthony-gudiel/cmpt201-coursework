# Inter-Process Communication
- **Inter-Process Communication** allows different processes and threads to communicate with
  each other

## Pipes
- `pipe(int filedes[2])` to create a new pipe
    - Creates 2 file descriptors in filedes
    - `filedes[0]` gives us the read end
    - `filedes[1]` gives us the write end
- Pipes use a buffer in the kernel
- Once you determine the sender and receiver, it cannot be changed
- Pipes are byte streams
    - One byte at a time
- Typical use case of pipes in parent-child communication:
    - First create a pipe, then call `fork()`
    - Both file descriptors are available in parent and child
- Important points about pipes:
    - Each process typically uses a different end (close the other)
    - The pipe's buffer size in the kernel is fixed at PIPE_BUF (4096 in Linux)
        - If n <= PIPE_BUF, it is atomic
        - If n > PIPE_BUF, it may not be atomic
    - Closing all `write()` file descriptors will make `read()` return 0 after returning all data
      from buffer
- `dup2(int oldfd, int newfd)` can redirect another program's input/output to pipes
    - Adjusts the file descriptor newfd so that it now refers to the same open file descriptor as
      oldfd
    - e.g. `dup2(filedes[1], STDOUT_FILENO)`: any writes to STDOUT are instead sent to write end of
      the pipe
    - e.g. `dup2(filedes[0], STDIN_FILENO)`: any reads from STDIN are instead read from the read end
      of the pipe
- `popen()` does three things to conveniently run a command:
    - Forks a new process and execs the command in the shell
    - Mode can be 'r' or 'w'

## FIFOs
- Two or more related processes can share a pipe, however unrelated processes cannot
- Instead, unrelated processes can communicate with each other through FIFOs
- A FIFO is a named pipe
    - `int mkfifo()`

## Message Queues
- Similar to a FIFO, but usually used to send structured data
    - A struct or union rather than a byte stream
    - `mq_open()`
- All messages in the queue are ordered based on their priority (priority queue)
    - `mq_receive()` retrieves the oldest highest priority message all at once
        - Whereas a pipe would only get some part of it

# Shared Memory
- If two processes have separate memory spaces, how can two processes share memory?

## Memory Mapping
- Memory mapping can be used to load a file into memory
    - Instead of `read()` and `write()`
- Also used to access memory-mapped devices
- `mmap()` creates a memory mapping
    - `int fd` is the open file to be mapped
- File mapping is when a file is loaded into a memory region
    - Replace `read()` or `write()` calls with pointer access to read or write file
- Anonymous mapping is another way to allocate memory to our process
    - In addition to `sbrk()`
    - MAP_ANONYMOUS is set
- Shared mapping: multiple processes can share a mapping
    - e.g. create a mapping, then fork a child
- Private mapping: changes in one process' memory mapping do not appear for the other process, and
  not written to file
- Private file mapping: Changes not written to file or shared with other processes
- Shared file mapping: changes propagate to the real file and other processes
    - Non-anonymous loads a file
- Private anonymous mapping: `fork()` copies the memory, but each process has a private copy
- Shared anonymous mapping: memory is shared, changes propagate to other process
    - Anonymous doesn't load a file into memory

## Shared Memory
- Two different ways to share memory between processes:
    - For related processes, create a memory map (parent), then share it with fork
        - `mmap()` with MAP_SHARED | MAP_ANONYMOUS
    - For unrelated processes, use a shared memory object
        - `shm_open()` in combination with `mmap()`
