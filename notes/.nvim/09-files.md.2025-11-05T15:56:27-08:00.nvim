# Files

## Basic I/O Syscalls
- **File Offset** is a pointer that points to a byte in the file where you operate
- `read()` and `write()` automatically increments the offset
    - Subsequent calls can continue with the next data
- `open()` is used to open a file and takes the following parameters:
    - `int flags` specifies O_RDONLY, O_WRONLY, O_RDWR
        - Flags can be bitwise OR'd
    - `mode_t mode` sets file permissions when creating file
        - S_IRUSR | S_IWUSR: user can read/write
        - S_IRWXU: user can execute
        - Returns a file descriptor that's a small positive int
        - Only needed when you create or set a temp file
- `write()` writes buf to a file descriptor and returns the number of bytes written
    - The number of bytes written may be less than the count due to something like insufficient
      space
- `read()` reads from a file descriptor and returns the number of bytes read
    - If the offset is at or past the end of the file, no bytes are read, and returns 0
    - Number of bytes read may be less than the number of bytes requested
- `close()` closes the file descriptor
- `lseek()` allows you to move the offset of a file manually
    - Argument `int whence` is from which location we want to adjust the file offset
    - Can set to SEEK_SET, SEEK_CUR, SEEK_END (start, current, and end)
    - End of the file is the 1st byte after end of data

## Buffered I/O
- Standard library (stdlib) functions
    - All I/O functions start with f
        - e.g. `fprintf()`, `fgets()`
- `fprintf()` manages a buffer in memory and writes to the buffer
    - No syscall required (unlike write()), therefore faster
    - Called buffered I/O
- Syscalls like `write()` take a file descriptor, while library functions like `fprintf()` take a
  stream (FILE *stream*)
- A file stream is a convenient wrapper around a file descriptor
    - Think of it as a file descriptor plus a buffer backing it up
- You can get a file stream from a file descriptor using `fdopen()`
- You can get the file descriptor from a file stream using `fileno()`
- When using `fprintf()`, the buffer needs to be manually flushed, or will flush when the program
  exits
    - Using `fflush()`
- A blocking I/O call doesn't return until the operation can be done
    - e.g. `read()` won't return until there's something to read
- A non-blocking I/O call is an operation that if it can't be done immediately, will return an error
    - Usually EAGAIN, to signify try again later

## The File System
- Devices like keyboards, hard-drives, and LEDs are all part of the file system
- The kernel dynamically populates information in the form of files
- 3 standard file descriptors are always opened by init by default
    - STDERR, STDIN, STDOUT
- Device files: many devices have a 'device file'
    - Some are real devices (e.g. mouse, keyboard)
    - Others are virtual devices (e.g. dev/null, dev/zero)
- /sys File System: shows kernel information
    - Device setups, kernel subsystem information, etc.
    - ioctl syscall is outside of the normal universal I/O model
- **Disk partitions**: a disk is divided into partitions
    - A partition is typically used as a file system
        - Used to manage files and directories
    - From the user's perspective, the file system is a tree
    - **Swap partition** is used as swap space for memory management (paging)
- **I-Nodes**: a file is associated with an i-node
    - Contains metadata about the file
        - Filetype, owner, etc.

- **Hard Links**: we can give many names to the same file
    - `rm` actually removes hard links
- **Soft Links**: also called symbolic links or sym links, is an actual file
    - The contents of the file is the path to the original file

## Virtual File System
- Defines the interface that different file systems can implement
- Linux presents all file systems as a single tree
- **Mounting**: combining multiple file trees into one
    - All file systems are mounted to form a single tree
